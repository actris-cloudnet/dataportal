import { Connection, Repository } from "typeorm";
import { Request, RequestHandler, Response } from "express";

import { RegularFile, ModelFile } from "../entity/File";
import { Collection } from "../entity/Collection";
import { formatList, getObjectLandingPage } from "../lib";
import { Citation, CitationService } from "../lib/cite";

export class ReferenceRoutes {
  private conn: Connection;
  private fileRepo: Repository<RegularFile>;
  private modelRepo: Repository<ModelFile>;
  private collectionRepo: Repository<Collection>;
  private citationService: CitationService;

  constructor(conn: Connection) {
    this.conn = conn;
    this.fileRepo = conn.getRepository("regular_file");
    this.modelRepo = conn.getRepository("model_file");
    this.collectionRepo = conn.getRepository("collection");
    this.citationService = new CitationService(conn);
  }

  getReference: RequestHandler = async (req, res, next) => {
    try {
      const object = await Promise.any([
        this.collectionRepo.findOneOrFail({ uuid: req.params.uuid }),
        this.fileRepo.findOneOrFail(
          { uuid: req.params.uuid },
          { relations: ["site", "site.citations", "site.citations.persons", "product"] }
        ),
        this.modelRepo.findOneOrFail(
          { uuid: req.params.uuid },
          { relations: ["site", "site.citations", "product", "model", "model.citations"] }
        ),
      ]);
      if (req.query.acknowledgements === "true") {
        await this.getAcknowledgements(req, res, object);
      } else if (req.query.dataAvailability === "true") {
        await this.getDataAvailability(req, res, object);
      } else {
        await this.getCitation(req, res, object);
      }
    } catch (err) {
      next(err);
    }
  };

  async getCitation(req: Request, res: Response, object: RegularFile | ModelFile | Collection) {
    const citation = await (object instanceof Collection
      ? this.citationService.getCollectionCitation(object)
      : this.citationService.getFileCitation(object));
    const citekey = (citation.authors.length > 0 ? citation.authors[0].lastName.toLowerCase() : "nn") + citation.year;
    if (req.query.format === "bibtex") {
      res.setHeader("Content-type", "text/plain; charset=utf-8");
      res.setHeader("Content-Disposition", `inline; filename="${citekey}.bib"`);
      res.send(citation2bibtex(citation, citekey));
    } else if (req.query.format === "ris") {
      res.setHeader("Content-type", "text/plain; charset=utf-8");
      res.setHeader("Content-Disposition", `inline; filename="${citekey}.ris"`);
      res.send(citation2ris(citation));
    } else if (req.query.format === "html") {
      res.setHeader("Content-type", "text/html; charset=utf-8");
      res.send(citation2html(citation));
    } else {
      res.json(citation);
    }
  }

  async getAcknowledgements(req: Request, res: Response, object: RegularFile | ModelFile | Collection) {
    res.setHeader("Content-type", "text/html; charset=utf-8");
    res.send(await this.citationService.getAcknowledgements(object));
  }

  async getDataAvailability(req: Request, res: Response, object: RegularFile | ModelFile | Collection) {
    const url = object.pid ? object.pid : getObjectLandingPage(object);
    const str = `The data used in this study are generated by the Aerosol, Clouds and Trace Gases Research Infrastructure (ACTRIS) and are available from the ACTRIS Data Centre using the following link: <a href="${url}">${url}</a>.`;
    res.setHeader("Content-type", "text/html; charset=utf-8");
    res.send(str);
  }
}

function citation2bibtex(c: Citation, citekey: string) {
  const fields = {
    author: c.authors.map((a) => `${a.lastName}, ${a.firstName}`).join(" and "),
    title: c.title,
    year: c.year,
    url: c.url,
    publisher: c.publisher,
    licence: getLicenseUrl(),
    note: c.note,
  };
  const bibtex = Object.entries(fields)
    .filter(([key, value]) => value !== undefined)
    .map(([key, value]) => `${key} = {${value}}`)
    .join(",\n  ");
  return `@misc{${citekey},\n  ${bibtex}\n}`;
}

function getInitials(name: string): string {
  return name.replace(/\p{L}+/gu, (part) => part.slice(0, 1) + ".");
}

function citation2html(c: Citation) {
  const authors = formatList(
    c.authors.map((a) => `${a.lastName}, ${getInitials(a.firstName)}`),
    ", & "
  );
  const year = `(${c.year})`;
  const title = c.title;
  const publisher = c.publisher;
  const link = `<a href="${c.url}">${c.url}</a>`;
  if (!authors) {
    return `${title}. ${year}. ${publisher}. ${link}`;
  }
  return `${authors} ${year}. ${title}. ${publisher}. ${link}`;
}

export function citation2txt(c: Citation) {
  const authors = formatList(
    c.authors.map((a) => `${a.lastName}, ${getInitials(a.firstName)}`),
    ", & "
  );
  const year = `(${c.year})`;
  const title = c.title;
  const publisher = c.publisher;
  const link = c.url;
  if (!authors) {
    return `${title}. ${year}. ${publisher}. ${link}`;
  }
  return `${authors} ${year}. ${title}. ${publisher}. ${link}`;
}

function citation2ris(c: Citation) {
  const newline = "\r\n";
  let authors = c.authors.map((a) => `AU  - ${a.lastName}, ${a.firstName}`).join(newline);
  if (authors == "") {
    authors = "AU  - ";
  }
  return [
    "TY  - DATA",
    authors,
    `T1  - ${c.title}`,
    `PY  - ${c.year}`,
    `PB  - ${c.publisher}`,
    `UR  - ${c.url}`,
    `N1  - ${c.note || ""}`,
    "ER  -",
  ].join(newline);
}

function getLicenseUrl() {
  return `https://creativecommons.org/licenses/by/4.0/`;
}
